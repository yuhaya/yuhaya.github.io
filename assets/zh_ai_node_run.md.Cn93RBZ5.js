import{_ as r,c as o,o as n,a2 as a}from"./chunks/framework.BfF5VrUX.js";const _=JSON.parse('{"title":"工作流执行原理","description":"","frontmatter":{},"headers":[],"relativePath":"zh/ai/node_run.md","filePath":"zh/ai/node_run.md"}'),s={name:"zh/ai/node_run.md"};function e(g,t,i,h,l,p){return n(),o("div",null,[...t[0]||(t[0]=[a('<h1 id="工作流执行原理" tabindex="-1">工作流执行原理 <a class="header-anchor" href="#工作流执行原理" aria-label="Permalink to &quot;工作流执行原理&quot;">​</a></h1><p>每一个节点的<strong>左边是输入端口</strong>，<strong>右边是输出端口</strong>，节点之间连线都是输出端口连线到下一个节点的输入端口，一个输出端口只能链接一个输入端口，一个输入端口可以被多个输出端口链接。</p><p><strong>启动入口</strong>节点是工作流执行的开始节点，当工作流启动后，系统会找到<strong>启动入口</strong>节点，然后从<strong>启动入口</strong>节点开始执行工作流。每个输出端口连接下一个节点的输入端口，触发下一个节点执行，每个节点执行完毕后，会传递数据给下一个节点，直到最后一个节点执行完毕。</p><p>以如下举例</p><p><img src="https://spub.xrobot.tech/blog/src/img/whatscrm/ai/node_run.png" alt="工作流执行原理" loading="lazy"></p><p>上图中的工作流一共6个节点，其中三个节点通过连线的方式连接在一起，另外三个则没有，那么工作流开始启动的时候，系统会找到<strong>启动入口</strong>节点，后面依次执行<strong>视频防查重</strong>节点，之后执行<strong>日志</strong>节点，其它三个没有连线的节点将不执行任何任务。</p><h2 id="输入端口类型的分类" tabindex="-1">输入端口类型的分类 <a class="header-anchor" href="#输入端口类型的分类" aria-label="Permalink to &quot;输入端口类型的分类&quot;">​</a></h2><h3 id="_1-任务驱动型" tabindex="-1">1. 任务驱动型 <a class="header-anchor" href="#_1-任务驱动型" aria-label="Permalink to &quot;1. 任务驱动型&quot;">​</a></h3><p>此输入端口的名称前有一个 <strong>&gt;</strong> 符号，并且<strong>端口名字是加粗的</strong>，只有此类端口有数据进入，才能出发节点执行任务，如上图中的6个节点，除了<strong>启动入口</strong>节点没有输出端口，其它5个节点都有一个任务驱动型输入端口。</p><h3 id="_2-关键数据型" tabindex="-1">2. 关键数据型 <a class="header-anchor" href="#_2-关键数据型" aria-label="Permalink to &quot;2. 关键数据型&quot;">​</a></h3><p>此输入端口的名称前<strong>没有</strong> <strong>&gt;</strong> 符号，<strong>只有端口名字是加粗的</strong>，只有此类端口数据接受到的数据量<strong>决定了该节点需要最多执行多少次任务</strong>，但是并<strong>不能触发节点执行任务</strong>。</p><p>以上面的Facebook批量发私信的节点为例，它的<strong>主页链接</strong>输入端口就是关键数据型端口，<strong>主页链接</strong>输入端口如果一共接收到10条主页链接数据，那么当在<strong>任务驱动型</strong>端口 <strong>&gt;入口</strong> 收到任意数据后，驱动节点执行任务，节点会查看关键数据型端口<strong>主页链接</strong>有10个待处理数据，所以会尝试创建10个私信任务，并执行。</p><h3 id="_3-可选数据型" tabindex="-1">3. 可选数据型 <a class="header-anchor" href="#_3-可选数据型" aria-label="Permalink to &quot;3. 可选数据型&quot;">​</a></h3><p>此输入端口的名称前<strong>没有</strong> <strong>&gt;</strong> 符号，<strong>端口名字没有加粗</strong>，此内端口数据仅起到节点创建自动化任务时的辅助作用。</p><p>以上面的Facebook批量发私信的节点为例，它的<strong>附件</strong>输入端口和<strong>文本</strong>输入端口就是可选数据型端口，接收到数据后<strong>不触发任何行为</strong>，仅起到辅助作用，当节点执行创建私信任务时，会从该辅助节点里面取数据，用于任务创建。</p><h2 id="输出端口类型的分类" tabindex="-1">输出端口类型的分类 <a class="header-anchor" href="#输出端口类型的分类" aria-label="Permalink to &quot;输出端口类型的分类&quot;">​</a></h2><p>输出端口没有类别区分，都是一样数据输出，用于连接后续节点的输入端口</p>',17)])])}const c=r(s,[["render",e]]);export{_ as __pageData,c as default};
